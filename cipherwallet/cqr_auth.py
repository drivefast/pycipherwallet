import uuid
import time
import base64
import odict
import hashlib
import hmac
import json

from db_interface import (
    verify_timestamp, verify_nonce, accepted_hash_method, 
    get_key_and_id_for_qr_login
)
from constants import API_SECRET

# common functions used by the QRAccess SDK

def auth(customer_id, secret_key, http_method, resource, params={}, hash_method="sha1"):
    """
    create and return a set of custom headers to go in a cqr-authorized API request, 
    including the corresponding CQR 1.0 Authorization: header
    """

    # initialize the custom authorization headers
    auth_headers = odict.odict()
    auth_headers['X-Client-Id'] = customer_id
    auth_headers['X-Timestamp'] = str(int(time.time()))
    auth_headers['X-Nonce'] = uuid.uuid4().hex
    auth_headers['X-Hash-Method'] = hash_method

    # prepare signature - headers and sorted parameters
    signature = http_method.upper() + " " + resource.lower() + "\n"
    for k, v in auth_headers.items():
        signature = signature + k + ":" + v + "\n"
    if type(params) == type({}):
        for k in sorted(params.iterkeys()):
            signature = signature + k + "=" + str(params[k]) + "\n"
        if len(params):
            signature = signature[:-1]
    elif type(params) == type(""):
        signature = signature + params

	# hash with client secret key and base64-encode
    h = ""
    if hash_method == "md5":
        h = hmac.new(secret_key, signature, hashlib.md5)
    elif hash_method == "sha1":
        h = hmac.new(secret_key, signature, hashlib.sha1)
    elif hash_method == "sha256":
        h = hmac.new(secret_key, signature, hashlib.sha256)
    elif hash_method == "sha512":
        h = hmac.new(secret_key, signature, hashlib.sha512)
    auth_headers['Authorization'] = "CQR 1.0 " + base64.b64encode(h.digest())

    # return the array of headers
    return auth_headers

def verify(http_method, uri, headers, params, authorization):
    """
    we verify a set of parameters against a given authorization string; return a boolean
    """
    if authorization is None:
        return False
    auth_parts = authorization.split()
    if (len(auth_parts) != 3) or (auth_parts[0] != "CQR") or (auth_parts[1] != "1.0"):
        return False
    received_crypto_sig = auth_parts[2]
    
    # recompose signature with method, url...
    signature = http_method.upper() + " " + uri.lower() + "\n"
    # ... auth headers...
    auth_headers = ['X-Client-Id', 'X-Timestamp', 'X-Nonce', 'X-Hash-Method']
    for header in auth_headers:
        value = headers.get(header)
        if value is None:
            return False
        signature = signature + header + ":" + value + "\n"
    # ... and request params (if any)
    if type(params) == type({}) and len(params) > 0:
        for k in sorted(params.iterkeys()):
            signature = signature + k + "=" + str(params[k]) + "\n"
        signature = signature[:-1]
    elif type(params) == type(""):
        signature = signature + params
    
    # verify timestamp drift
    if not verify_timestamp(int(headers['X-Timestamp'])):
        return False
    # verify nonce uniqueness
    if not verify_nonce(headers['X-Client-Id'], headers['X-Nonce']):
        return False
    
    # build encrypted signature
    h = ""
    if headers['X-Hash-Method'] == "md5":
        h = hmac.new(API_SECRET, signature, hashlib.md5)
    elif headers['X-Hash-Method'] == "sha1":
        h = hmac.new(API_SECRET, signature, hashlib.sha1)
    elif headers['X-Hash-Method'] == "sha256":
        h = hmac.new(API_SECRET, signature, hashlib.sha256)
    elif headers['X-Hash-Method'] == "sha512":
        h = hmac.new(API_SECRET, signature, hashlib.sha512)

    return base64.b64encode(h.digest()) == received_crypto_sig

def authorize(auth_data):
    # A mobile user sent us, via the API server, an array of parameters:
    #    user= their user id
    #    timestamp= the request timestamp collected at source, in epoch format
    #    nonce= a string randomly generated by the user, that should not repeat in a certain time interval
    #    hash_method= the hash method used to generate the authorization string
    #    authorization= the authorization string
    # We reconstruct the signature based on this data, and check that we have the same signature hash 
    #    for them in our database

    # user data validation
    user = auth_data.get('cw_user', "")
    authorization = auth_data.get('authorization', "")
    timestamp = auth_data.get('timestamp', "")
    nonce = auth_data.get('nonce', "")
    h_meth = accepted_hash_method(auth_data.get('hash_method', ""))
    if (
        len(user) == 0 or 
        len(authorization) == 0 or 
        not timestamp.isdigit() or 
        not verify_timestamp(int(timestamp)) or 
        not verify_nonce(user, nonce) or 
        len(h_meth) == 0 
    ):
        return None
    
    # lets go
    # pull signature from list of auth parameters - doesnt go into calculation
    h_sig_received = authorization.replace(".", "+")
    del auth_data['authorization']
    # order the user's auth params list and build the signature string
    signature = ""
    for k in sorted(auth_data.iterkeys()):
        signature = signature + k + "=" + str(auth_data[k]) + "\n"
    signature = signature[:-1]
    
    # get user's secret key and hash the signature with it
    uid, uk, umeth = get_key_and_id_for_qr_login(user)
    if uid is None or umeth != h_meth:
        return None
    h = ""
    if h_meth == "md5":
        h = hmac.new(uk, signature, hashlib.md5)
    elif h_meth == "sha1":
        h = hmac.new(uk, signature, hashlib.sha1)
    elif h_meth == "sha256":
        h = hmac.new(uk, signature, hashlib.sha256)
    elif h_meth == "sha512":
        h = hmac.new(uk, signature, hashlib.sha512)

    return uid if base64.b64encode(h.digest()) == h_sig_received else None

